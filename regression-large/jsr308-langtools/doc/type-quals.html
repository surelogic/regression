<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>type-quals</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -exec xxdate.exe urlhref.hva type-quals.tex -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Custom type qualifiers via annotations on Java types</H1><H3 CLASS="titlerest">Matthew M. Papi and Michael D. Ernst<BR>
<TT>mernst@cs.washington.edu</TT><BR>
March&#XA0;18, 2012</H3></TD></TR>
</TABLE><P>A separate document, &#X201C;Type annotations (JSR 308)&#X201D;, presents a proposal for
extending the syntax of Java (and the class file format) to permit
annotations on any use of a type in Java. By contrast, the current Java
standard only permits annotations on declarations, which is less general
and restricts how annotations can be utilized.</P><P>The &#X201C;Type annotations&#X201D; document specifies the syntax of Java
annotations, but not their semantics. The semantics of each annotation is
defined by its author, who also creates plug-ins to check and enforce those
semantics. Those plug-ins can operate at compile time and load time &#X2014;
making guarantees about run-time behavior requires load-time checking, but
compile-time checking is useful as an early check and is more convenient
for programmers.</P><P>This document explores implementation strategies for plug-ins that check
annotations. These strategies are equally valid for Java&#X2019;s original
annotations and for the new extended annotations. Both compile-time and
load-time processing are outside the scope of the annotations proposal, but
are presented here as an example of how annotations on types might be used.
The processors described here do not require any further changes to Java
beyond those described in the &#X201C;Type annotations&#X201D; document.</P><!--TOC section Compile-Time Processing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Compile-Time Processing</H2><!--SEC END --><P>
<A NAME="sec:compile-time"></A></P><P>A compiler plug-in that enforces annotation semantics (for type qualifiers
or any other use) can be written using JSR-269 (the pluggable annotation
processing API) and the Tree API, which were defined for just such a
purpose. The Tree API allows an application to obtain and traverse (but
not modify) an instance of a program&#X2019;s abstract syntax tree. JSR-269
provides a set of classes for working with annotations, as well as an
interface to the compiler so that annotation processing code can be run,
and errors issued, at compile-time. These interfaces must be slightly
extended to accommodate the new locations for annotations.
</P><P>A plug-in developer can create a
class that extends JSR-269&#X2019;s <TT>AbstractProcessor</TT> and provide an
implementation of its <TT>process</TT> method. During compilation, the
compiler calls <TT>process</TT> when it encounters annotations, passing
these annotations as arguments. The <TT>process</TT> method&#X2019;s
implementation can use the Tree API to obtain and analyze the program
elements surrounding the annotation. If the plug-in discovers a
violation of a type qualifier&#X2019;s semantics, the <TT>process</TT> method
can use the JSR-269 <TT>Messager</TT> class to report the violation as
an error or warning.</P><P>A framework for writing compiler plug-ins is outside the scope of this
proposal. After obtaining some experience with compiler plug-ins, we or
others may propose support for writing them, perhaps
in the spirit of [<A HREF="#ChinMM2005">CMM05</A>].</P><P>In keeping with Java&#X2019;s separate compilation model, the Tree API gives
access to the AST for all <TT>.java</TT> files that are being compiled; a
plug-in has access only to signatures for code that is read from <TT>.class</TT>
files. A whole-program analysis might need to use a separate
infrastructure, and is outside the scope of this proposal.</P><!--TOC section Load-Time Processing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;Load-Time Processing</H2><!--SEC END --><P>
<A NAME="sec:load-time"></A></P><P>Whenever compile-time checking is used for a given annotation, then
load-time checking is required as well. This is exactly how Java already
works. The byte-code verifier is the key type-checker for Java, which
enforces the guarantees of the type system and prevents certain run-time
errors. By contrast, the Java compiler (e.g., <TT>javac</TT>) is a
programmer convenience that provides early warnings but cannot make
guarantees on its own.</P><P>Load-time checking is necessary for two general reasons: unchecked
bytecodes and changes in environment.
The first reason is that bytecodes can be produced from any source,
including being directly constructed, being produced by a buggy compiler,
or being produced by a malicious party. To guarantee type safety, the JVM
must check the bytecodes. Similarly, the compiler reads and trusts the
annotations on signatures of called methods; a type safety guarantee
requires the entire program to be checked at load time.
The second reason is that the environment &#X2014; such as called methods &#X2014;
may change between the time that a class is compiled and the time that it
is loaded/run, for instance if a library it calls is changed and
recompiled. Again, the only way to guarantee type safety is to check the
entire program at once, at load time.</P><P>A type-checking plug-in that enforces annotation (e.g., type qualifier) semantics at load time can be
invoked from the <TT>premain</TT> method, and can use a third-party bytecode
library for convenient analysis of the bytecodes of loaded classes. In
Java, the <TT>premain</TT> method can be used to perform bytecode
analysis (and instrumentation) just before a program&#X2019;s <TT>main</TT>
method is invoked.</P><P>A plug-in developer can create a class that declares a <TT>premain</TT>
method. The virtual machine invokes <TT>premain</TT>, passing an
instance of <TT>java.lang.instrument.Instrumentation</TT> as an
argument. This instance allows the developer to obtain an array of
loaded classes, which the bytecode library can convert to its own
representation. This representation can then be used to traverse the
bytecodes of each class&#X2019;s methods and perform verification of a type
qualifier&#X2019;s semantics &#X2014; all before the virtual machine invokes the
program&#X2019;s <TT>main</TT> method.</P><P>As with compile-time processing, 
a framework for writing load-time plug-ins is outside the scope of this
proposal. After obtaining some experience with JVM plug-ins, we or
others may propose support for writing them, perhaps
in the spirit of [<A HREF="#Fong2004">Fon04</A>].</P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="ChinMM2005"><FONT COLOR=purple>[CMM05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian Chin, Shane Markstrum, and Todd Millstein.
Semantic type qualifiers.
In <EM>Proceedings of the </EM><EM>ACM</EM><EM> </EM><EM>SIGPLAN</EM><EM> 2005 Conference on
Programming Language Design and Implementation</EM>, pages 85&#X2013;95, Chicago, IL,
USA, June&#XA0;13&#X2013;15, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="Fong2004"><FONT COLOR=purple>[Fon04]</FONT></A></DT><DD CLASS="dd-thebibliography">
Philip W.&#XA0;L. Fong.
Pluggable verification modules: An extensible protection mechanism
for the JVM.
In <EM>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2004)</EM>, pages 404&#X2013;418, Vancouver, BC, Canada,
October&#XA0;26&#X2013;28, 2004.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</BODY>
</HTML>
